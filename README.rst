velvet-stats
==============

**velvet-stats** is a command-line utility that analyze sequence assemblies generated by the open-source **Velvet** short-reads assembler (http://www.ebi.ac.uk/~zerbino/velvet/), and produce a .csv-formatted output of their key metrics.

**velvet-stats** main purpose is to facilitate the comparison of Velvet assemblies based on different values of k-mer length or expected coverage. The .csv-formatted report **velvet-stats** produces contains metrics such as N50, number of large contigs, etc. which can be used to select the optimum k-mer or expected coverage.

**velvet-stats** is very similar to **VelvetOptimiser** (http://bioinformatics.net.au/software.velvetoptimiser.shtml). However **VelvetOptimiser** will only produce a report on assemblies it run itself. **velvet-stats** is more flexible, by allowing you to compare any pre-existing assemblies. As such, **velvet-stats** is particularly useful when assemblies have been performed on a cluster of computers, or by different teams, and need to be compared.

Installation
------------

To install **velvet-stats** you must go through the following steps:

- ensure a Python interpreter (version 2.6 or 2.7; 3.0 and later are not supported yet) is installed in your system. Please refer to this `page <http://www.python.org/getit/>`__ if needed.
- ensure the Biopython library is installed. Please refer to this `page <http://biopython.org/DIST/docs/install/Installation.html>`__ if needed.
- go to http://github.com/ajmazurie/velvet-stats/zipball/master. A file named *ajmazurie-velvet-stats-xxxx.zip* will download (xxxx will be replaced by a commit signature code).
- unzip this file.
- ensure the file *velvet-stats* is in your `PATH <http://kb.iu.edu/data/acar.html>`__, either by moving it to a directory already in your PATH or by adding this directory to the PATH.

Usage
-----

A list of options can be obtained by using the *--help* option::

	Usage: velvet-stats [options] outdir <outdir2> ...

	Options:
	  -h, --help            show this help message and exit
	  -o FILENAME, --output=FILENAME
	                        (mandatory) destination of the .csv-formatted report
	  -v, --verbose         (optional) if set, will display debug information

The *outdir* argument(s) are directories containing Velvet assemblies. **velvet-stats** will test for the presence of key files in each such directory, and reject those with missing information.

The output file contains the following fields:

.. csv-table::

	*kmer_length*,length of the k-mer hash
	*n_sequences*,number of contigs
	*n_long_sequences*,number of contigs with size above or equal 1kb
	*n_short_sequences*,number of contigs with size below 1kb
	*n_bases*,"number of characters, including gap characters 'N'"
	*n_N*,number of gaps (character 'N') in the assembly
	*n_non_N*,number of nucleotides (characters other than 'N') in the assembly
	*min_length*,smallest contig length
	*max_length*,largest contig length
	*avg_length*,average contig length
	*N50*,N50 length
	*exp_cov*,expected coverage
	*outdir*,path to the assembly directory

Example
-------

Let us imagine a situation where *velveth* is used to test a range of k-mer lengths for an assembly::

	% velveth my_assemblies/ 11,33,2 -short -fasta my_reads.fasta

Here we will end up with multiple directories *my_assemblies/_11*, *my_assemblies/_13*, etc. which can then be assembled individually using *velvetg*::

	% velvetg my_assemblies/_11
	% velvetg my_assemblies/_13
	...

To create a report on these multiple assemblies, simply type ::

	% velvet-stats my_assemblies/* -o report.csv

The resulting file *report.csv* will look something like

.. csv-table::
	:header-rows: 1

	kmer_length,n_sequences,n_long_sequences,n_short_sequences,n_bases,n_N,n_non_N,min_length,max_length,avg_length,N50,exp_cov,outdir
	13,4594,0,4594,122240,0,122240,25,59,26.6086199391,26,235,"my_assemblies/_13"
	15,562264,0,562264,22238651,0,22238651,29,229,39.5519738059,38,180,"my_assemblies/_15"
	17,385447,13,385434,36694352,270,36694082,33,1317,95.1994748954,111,204,"my_assemblies/_17"
	19,164986,3447,161539,35988020,410,35987610,37,5843,218.127719928,319,171,"my_assemblies/_19"
	21,129391,5261,124130,34982035,190,34981845,41,16392,270.359105347,438,192,"my_assemblies/_21"
	23,122794,4714,118080,33956726,150,33956576,45,18445,276.53408147,437,312,"my_assemblies/_23"
	25,118378,4390,113988,32862691,90,32862601,49,23061,277.608094409,418,234,"my_assemblies/_25"
	27,110395,3954,106441,31307659,90,31307569,53,23063,283.596711808,402,336,"my_assemblies/_27"
	29,106079,3618,102461,29893870,70,29893800,57,26144,281.807615079,380,432,"my_assemblies/_29"
	31,101842,3355,98487,28404815,100,28404715,61,21233,278.910616445,357,285,"my_assemblies/_31"

In this case, we can see that a k-mer length of 21 appears to maximize both the N50 and the number of long contigs.
